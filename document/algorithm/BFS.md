要说框架的话，我们先举例一下 BFS 出现的常见场景好吧，
问题的本质就是让你在一幅「图」中找到从起点 start 到终点
 target 的最近距离，这个例子听起来很枯燥，但是 BFS 算法
 问题其实都是在干这个事儿，把枯燥的本质搞清楚了，再去欣
 赏各种问题的包装才能胸有成竹嘛。
这个广义的描述可以有各种变体，比如走迷宫，有的格子是围
墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带
「传送门」可以瞬间传送呢？
再比如说两个单词，要求你通过某些替换，把其中一个变成
另一个，每次只能替换一个字符，最少要替换几次？
再比如说连连看游戏，两个方块消除的条件不仅仅是图案
相同，还得保证两个方块之间的最短连线不能多于两个拐点。
你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线
有几个拐点的？


`// 计算从起点 start 到终点 target 的最近距离
 int BFS(Node start, Node target) {
     Queue<Node> q; // 核心数据结构
     Set<Node> visited; // 避免走回头路
 
     q.offer(start); // 将起点加入队列
     visited.add(start);
     int step = 0; // 记录扩散的步数
 
     while (q not empty) {
         int sz = q.size();
         /* 将当前队列中的所有节点向四周扩散 */
         for (int i = 0; i < sz; i++) {
             Node cur = q.poll();
             /* 划重点：这里判断是否到达终点 */
             if (cur is target)
                 return step;
             /* 将 cur 的相邻节点加入队列 */
             for (Node x : cur.adj())
                 if (x not in visited) {
                     q.offer(x);
                     visited.add(x);
                 }
         }
         /* 划重点：更新步数在这里 */
         step++;
     }
 }`
 
 
 - 为什么 BFS 可以找到最短距离，DFS 不行吗？
 
 首先，你看 BFS 的逻辑，depth 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。
 DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。
 形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。
 
 - 既然 BFS 那么好，为啥 DFS 还要存在？
 
 BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。
 还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 N，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 O(logN)。
 但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2，用 Big O 表示的话也就是 O(N)。
 由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。